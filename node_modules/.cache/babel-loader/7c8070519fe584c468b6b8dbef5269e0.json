{"ast":null,"code":"'use strict';/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */function speedometer(samplesCount,min){samplesCount=samplesCount||10;var bytes=new Array(samplesCount);var timestamps=new Array(samplesCount);var head=0;var tail=0;var firstSampleTS;min=min!==undefined?min:1000;return function push(chunkLength){var now=Date.now();var startedAt=timestamps[tail];if(!firstSampleTS){firstSampleTS=now;}bytes[head]=chunkLength;timestamps[head]=now;var i=tail;var bytesCount=0;while(i!==head){bytesCount+=bytes[i++];i=i%samplesCount;}head=(head+1)%samplesCount;if(head===tail){tail=(tail+1)%samplesCount;}if(now-firstSampleTS<min){return;}var passed=startedAt&&now-startedAt;return passed?Math.round(bytesCount*1000/passed):undefined;};}export default speedometer;","map":{"version":3,"names":["speedometer","samplesCount","min","bytes","Array","timestamps","head","tail","firstSampleTS","undefined","push","chunkLength","now","Date","startedAt","i","bytesCount","passed","Math","round"],"sources":["/home/leejungwon/BEB-06-PrivateSea/src/node_modules/axios/lib/helpers/speedometer.js"],"sourcesContent":["'use strict';\n\n/**\n * Calculate data maxRate\n * @param {Number} [samplesCount= 10]\n * @param {Number} [min= 1000]\n * @returns {Function}\n */\nfunction speedometer(samplesCount, min) {\n  samplesCount = samplesCount || 10;\n  const bytes = new Array(samplesCount);\n  const timestamps = new Array(samplesCount);\n  let head = 0;\n  let tail = 0;\n  let firstSampleTS;\n\n  min = min !== undefined ? min : 1000;\n\n  return function push(chunkLength) {\n    const now = Date.now();\n\n    const startedAt = timestamps[tail];\n\n    if (!firstSampleTS) {\n      firstSampleTS = now;\n    }\n\n    bytes[head] = chunkLength;\n    timestamps[head] = now;\n\n    let i = tail;\n    let bytesCount = 0;\n\n    while (i !== head) {\n      bytesCount += bytes[i++];\n      i = i % samplesCount;\n    }\n\n    head = (head + 1) % samplesCount;\n\n    if (head === tail) {\n      tail = (tail + 1) % samplesCount;\n    }\n\n    if (now - firstSampleTS < min) {\n      return;\n    }\n\n    const passed = startedAt && now - startedAt;\n\n    return  passed ? Math.round(bytesCount * 1000 / passed) : undefined;\n  };\n}\n\nexport default speedometer;\n"],"mappings":"AAAA,YAAY,CAEZ;AACA;AACA;AACA;AACA;AACA,GACA,QAASA,YAAW,CAACC,YAAY,CAAEC,GAAG,CAAE,CACtCD,YAAY,CAAGA,YAAY,EAAI,EAAE,CACjC,GAAME,MAAK,CAAG,GAAIC,MAAK,CAACH,YAAY,CAAC,CACrC,GAAMI,WAAU,CAAG,GAAID,MAAK,CAACH,YAAY,CAAC,CAC1C,GAAIK,KAAI,CAAG,CAAC,CACZ,GAAIC,KAAI,CAAG,CAAC,CACZ,GAAIC,cAAa,CAEjBN,GAAG,CAAGA,GAAG,GAAKO,SAAS,CAAGP,GAAG,CAAG,IAAI,CAEpC,MAAO,SAASQ,KAAI,CAACC,WAAW,CAAE,CAChC,GAAMC,IAAG,CAAGC,IAAI,CAACD,GAAG,EAAE,CAEtB,GAAME,UAAS,CAAGT,UAAU,CAACE,IAAI,CAAC,CAElC,GAAI,CAACC,aAAa,CAAE,CAClBA,aAAa,CAAGI,GAAG,CACrB,CAEAT,KAAK,CAACG,IAAI,CAAC,CAAGK,WAAW,CACzBN,UAAU,CAACC,IAAI,CAAC,CAAGM,GAAG,CAEtB,GAAIG,EAAC,CAAGR,IAAI,CACZ,GAAIS,WAAU,CAAG,CAAC,CAElB,MAAOD,CAAC,GAAKT,IAAI,CAAE,CACjBU,UAAU,EAAIb,KAAK,CAACY,CAAC,EAAE,CAAC,CACxBA,CAAC,CAAGA,CAAC,CAAGd,YAAY,CACtB,CAEAK,IAAI,CAAG,CAACA,IAAI,CAAG,CAAC,EAAIL,YAAY,CAEhC,GAAIK,IAAI,GAAKC,IAAI,CAAE,CACjBA,IAAI,CAAG,CAACA,IAAI,CAAG,CAAC,EAAIN,YAAY,CAClC,CAEA,GAAIW,GAAG,CAAGJ,aAAa,CAAGN,GAAG,CAAE,CAC7B,OACF,CAEA,GAAMe,OAAM,CAAGH,SAAS,EAAIF,GAAG,CAAGE,SAAS,CAE3C,MAAQG,OAAM,CAAGC,IAAI,CAACC,KAAK,CAACH,UAAU,CAAG,IAAI,CAAGC,MAAM,CAAC,CAAGR,SAAS,CACrE,CAAC,CACH,CAEA,cAAeT,YAAW"},"metadata":{},"sourceType":"module"}